#!/usr/bin/env python
# -*- coding: utf8 -*-

import pygtk
pygtk.require20()
import gtk

from twisted.internet import gtk2reactor
gtk2reactor.install()

import logging
import os.path

from ConfigParser import ConfigParser

from twisted.internet import defer
from twisted.internet import reactor
from twisted.internet import task

from rss_monkey.client import RssClient
from rss_monkey.common.utils import singleton

# TODO: konfigurace logovani
LOG = logging.getLogger('FeedProcessorClient')

CONFIG_FILE = '/etc/rss_monkey_client.ini'


@singleton
class Config(object):
    def __init__(self):
        self.parser = ConfigParser()
        self.parser.read(CONFIG_FILE)

    def get(self, section, option):
        return self.parser.get(section, option)


@singleton
class UserConfig(object):
    def __init__(self):
        self.path = os.path.expanduser('~/.rss_monkey.ini')
        self.parser = ConfigParser()
        self.parser.read(self.path)

    def get(self, section, option):
        return self.parser.get(section, option)

    def set(self, section, option, value=None):
        if not self.parser.has_section(section):
            self.parser.add_section(section)

        self.parser.set(section, option, value)

    def write(self):
        with open(self.path, 'w') as f:
            self.parser.write(f)


class Task(object):

    def __init__(self, fnc, canceller=None, *args, **kw):
        self.deferred = defer.Deferred(canceller)

        self._fnc = fnc
        self._args = args
        self._kw = kw

    def run(self):
        d = task.deferLater(reactor, 0, self._fnc, *self._args, **self._kw)
        d.chainDeferred(self.deferred)

        return self.deferred

    def cancel(self):
        self.deferred.cancel()


class ScheduledTask(object):

    def __init__(self, fnc, canceller=None, *args, **kw):
        self.deferred = defer.Deferred(canceller)

        self._fnc = fnc
        self._args = args
        self._kw = kw

    def schedule(self, seconds):
        d = task.deferLater(reactor, seconds, self._fnc, *self._args, **self._kw)
        d.chainDeferred(self.deferred)

        return self.deferred

    def cancel(self):
        self.deferred.cancel()


class ConfigurationWindow(object):
    def __init__(self, ui_file, salt):
        self._init_window(ui_file)
        self.salt = salt

        self.server_status_task = None
        self.login_status_task = None

    def _init_window(self, ui_file):
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_file)

        signals = {'on_register_button_clicked': self.on_register_button_clicked,
                   'on_cancel_button_clicked': lambda widget, *data: self.close(),
                   'on_ok_button_clicked': self.on_ok_button_clicked,
                   'on_server_url_entry_changed': self.on_server_url_entry_changed,
                   'on_login_entry_changed': self.on_credentials_changed,
                   'on_passwd_entry_changed': self.on_credentials_changed}

        self.builder.connect_signals(signals)

        self._set_widget_objects()

        self.dialog.connect('destroy', lambda widget, *data: self.close())
        self.dialog.set_modal(True)

    def _set_widget_objects(self):
        widgets = ('dialog', 'server_url_entry', 'login_entry', 'passwd_entry',
                   'login_status', 'server_status')
        go = self.builder.get_object
        for widget_name in widgets:
            setattr(self, widget_name, go(widget_name))

    def close(self):
        self.dialog.hide()
        self.dialog.destroy()

    def show(self):
        self.dialog.show()

    @defer.inlineCallbacks
    def on_register_button_clicked(self, widget, *data):
        self.dialog.set_sensitive(False)
        try:
            login = self.login_entry.get_text().strip()
            passwd = self.passwd_entry.get_text().strip()

            self.login_status.set_text('...')

            if not login or not passwd:
                return

            url = self.server_url_entry.get_text().strip()

            if not url:
                return

            pwdhash = self._create_passwd_hash(passwd)

            try:
                yield RssClient.register_user(url, login, pwdhash)

                print 'User registered:', login
                self.login_status.set_text(' OK')
            except Exception as e:
                print e.__class__.__name__, str(e)
                self.login_status.set_text('ERR')
        finally:
            self.dialog.set_sensitive(True)

    def on_ok_button_clicked(self, widget, *data):
        login = self.login_entry.get_text().strip()
        passwd = self.passwd_entry.get_text().strip()
        url = self.server_url_entry.get_text().strip()

        if not login:
            self._show_error_dialog('Není zadán login.')

        if not passwd:
            self._show_error_dialog('Není zadáno heslo.')

        if not url:
            self._show_error_dialog('Není zadána URL serveru.')

        pwdhash = self._create_passwd_hash(passwd)

        cfg = UserConfig()
        cfg.set('user', 'login', login)
        cfg.set('user', 'passwd', pwdhash)
        cfg.set('server', 'url', url)
        cfg.write()

        self.close()

    @defer.inlineCallbacks
    def on_server_url_entry_changed(self, widget, *data):
        if self.server_status_task:
            self.server_status_task.cancel()

        self.server_status.set_text('...')

        url = self.server_url_entry.get_text().strip()

        self.server_status_task = ScheduledTask(self._check_connection, url=url)
        try:
            yield self.server_status_task.schedule(1)

            print 'Server URL: OK'
            self.server_status.set_text(' OK')
        except Exception as e:
            print e.__class__.__name__, str(e)
            self.server_status.set_text(' X ')

    @defer.inlineCallbacks
    def on_credentials_changed(self, widget, *data):
        login = self.login_entry.get_text().strip()
        passwd = self.passwd_entry.get_text().strip()

        if self.login_status_task:
            self.login_status_task.cancel()

        self.login_status.set_text('...')

        if not login or not passwd:
            return

        url = self.server_url_entry.get_text().strip()

        if not url:
            return

        self.login_status_task = ScheduledTask(self._check_credentials, url=url,
                                               login=login, passwd=passwd)
        try:
            yield self.login_status_task.schedule(1)

            print 'Credentials: OK'
            self.login_status.set_text(' OK')
        except Exception as e:
            print e.__class__.__name__, str(e)
            self.login_status.set_text(' X ')

    def _check_connection(self, url):
        return RssClient.test_connection(url)

    def _check_credentials(self, url, login, passwd):
        pwdhash = self._create_passwd_hash(passwd)
        client = RssClient()
        client.connect(url, login, pwdhash)
        return client.get_channels()  # do request with credentials

    def _create_passwd_hash(self, passwd):
        assert self.salt, 'salt not set'
        from hashlib import sha256
        digest = sha256(self.salt + passwd)
        return digest.hexdigest()

    def _show_error_dialog(self, message):
        dialog = gtk.MessageDialog(self.dialog,
                                   gtk.DIALOG_DESTROY_WITH_PARENT,
                                   gtk.MESSAGE_ERROR,
                                   gtk.BUTTONS_CLOSE, message)
        dialog.run()
        dialog.destroy()


class MainWindow(object):
    def __init__(self, ui_file):
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_file)

        signals = {'on_quit_mi_activate': gtk.main_quit,
                   'on_connect_mi_activate': self.on_connect_mi_activate,
                   'on_disconnect_mi_activate': self.on_disconnect_mi_activate,
                   'on_config_mi_activate': self.on_config_mi_activate,
                   'on_new_channel_mi_activate': self.on_new_channel_mi_activate,
                   'on_del_channel_mi_activate': self.on_del_channel_mi_activate,
                   'on_refresh_mi_activate': self.on_refresh_mi_activate,
                   'on_about_mi_activate': self.on_about_mi_activate}

        self.builder.connect_signals(signals)

        self._set_widget_objects()

        self.main_window.connect('destroy', lambda widget, *data: self.exit())

    def _set_widget_objects(self):
        widgets = ('main_window',)
        go = self.builder.get_object
        for widget_name in widgets:
            setattr(self, widget_name, go(widget_name))

    def show(self):
        self.main_window.show_all()

    def exit(self):
        reactor.stop()

    def on_config_mi_activate(self, widget, *data):
        self.main_window.set_sensitive(False)
        try:
            ui_file = Config().get('ui', 'config_dialog_path')
            salt = Config().get('global', 'salt')
            window = ConfigurationWindow(ui_file, salt)
            window.show()
        finally:
            self.main_window.set_sensitive(True)

    def on_connect_mi_activate(self, widget, *data):
        pass

    def on_disconnect_mi_activate(self, widget, *data):
        pass

    def on_new_channel_mi_activate(self, widget, *data):
        pass

    def on_del_channel_mi_activate(self, widget, *data):
        pass

    def on_refresh_mi_activate(self, widget, *data):
        pass

    def on_about_mi_activate(self, widget, *data):
        pass


def main():
    ui_file = Config().get('ui', 'main_window_path')
    main_window = MainWindow(ui_file)
    main_window.show()

    reactor.run()

if __name__ == '__main__':
    main()
